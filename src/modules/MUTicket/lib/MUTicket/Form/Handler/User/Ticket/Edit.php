<?php
/**
 * MUTicket.
 *
 * @copyright Michael Ueberschaer
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package MUTicket
 * @author Michael Ueberschaer <kontakt@webdesign-in-bremen.com>.
 * @link http://www.webdesign-in-bremen.com
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.5.3 (http://modulestudio.de) at Tue Oct 11 10:27:49 CEST 2011.
 */

/**
 * This handler class handles the page events of the Form called by the MUTicket_user_edit() function.
 * It aims on the ticket object type.
 */
class MUTicket_Form_Handler_User_Ticket_Edit extends MUTicket_Form_Handler_Base_User_Ticket_Edit
{
/**
* Initialize form handler.
*
* This method takes care of all necessary initialisation of our data and form states.
*
* @return boolean False in case of initialization errors, otherwise true.
*/
    public function initialize(Zikula_Form_View $view)
    {
        $this->inlineUsage = ((UserUtil::getTheme() == 'Printer') ? true : false);
        $this->idPrefix = $this->request->getGet()->filter('idp', '', FILTER_SANITIZE_STRING);

        // initialise redirect goal
        $this->returnTo = $this->request->getGet()->filter('returnTo', null, FILTER_SANITIZE_STRING);
        // store current uri for repeated creations
        $this->repeatReturnUrl = System::getCurrentURI();

        $this->objectType = 'ticket';

        $entityClass = 'MUTicket_Entity_' . ucfirst($this->objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        $objectTemp = new $entityClass();
        $idFields = $objectTemp->get_idFields();

        // retrieve identifier of the object we wish to view
        $this->idValues = MUTicket_Util_Controller::retrieveIdentifier($this->request, array(), $this->objectType, $idFields);
        $hasIdentifier = MUTicket_Util_Controller::isValidIdentifier($this->idValues);

        $entity = null;
        $this->mode = ($hasIdentifier) ? 'edit' : 'create';
        
        $funcType = $this->request->getGet()->filter('func', null, FILTER_SANITIZE_STRING);
        if($funcType == 'display') {
         $this->mode = 'create';
        }
        
        //if($this->mode == 'create' && $funcType != 'display') {
         //$this->idValues[$idField] = 4;
        //}
        
        $ticketid = $this->request->getGet()->filter('id', '' , FILTER_SANITIZE_NUMBER_INT);
        
        if ($this->mode == 'edit') {
            if (!SecurityUtil::checkPermission('MUTicket:Ticket:', '::', ACCESS_EDIT)) {
                // set an error message and return false
                return $this->view->setErrorMsg(LogUtil::registerPermissionError());
            }

        $entity = $repository->selectById($this->idValues);
        if (!is_object($entity) || !isset($entity[$idFields[0]])) {
            return $this->view->setErrorMsg($this->__('No such item.'));
        }

            // try to guarantee that only one person at a time can be editing this ticket
            $itemID = '';
            foreach ($idFields as $idField) {
                if (!empty($itemID)) {
                    $itemID .= '_';
                }
                $itemID .= $this->idValues[$idField];
            }
            $returnUrl = ModUtil::url('MUTicket', 'user', 'display', array('ot' => 'ticket', 'id' => $this->idValues['id']));
            ModUtil::apiFunc('PageLock', 'user', 'pageLock',
                                 array('lockName' => 'MUTicketTicket' . $itemID,
                                       'returnUrl' => $returnUrl));
        }
        else {
            if (!SecurityUtil::checkPermission('MUTicket:Ticket:', '::', ACCESS_ADD)) {
                return $this->view->setErrorMsg(LogUtil::registerPermissionError());
            }

            $hasTemplateId = false;
            $templateId = $this->request->getGet()->get('astemplate', '');
            if (!empty($templateId)) {
                $templateIdValueParts = explode('_', $templateId);
                $hasTemplateId = (count($templateIdValueParts) == count($idFields));
            }
            if ($hasTemplateId === true) {
                $templateIdValues = array();
                $i = 0;
                foreach ($idFields as $idField) {
                    $templateIdValues[$idField] = $templateIdValueParts[$i];
                    $i++;
                }
                // reuse existing ticket
        $entity = $repository->selectById($templateIdValues);
        if (!is_object($entity) || !isset($entity[$idFields[0]])) {
            return $this->view->setErrorMsg($this->__('No such item.'));
        }
                //foreach ($idFields as $idField) {
                // $entity[$idField] = null;
                //}
            }
            else {
                $entity = new $entityClass();

                $entity['parent'] = $this->retrieveRelatedObjects('ticket', 'parent', false);
                $entity['rating'] = $this->retrieveRelatedObjects('rating', 'rating', true);
                $entity['children'] = $this->retrieveRelatedObjects('ticket', 'children', true);
            }
        }

        $entityData = $entity->toArray();

        // assign data to template as array for easy translatable support
        $this->view->assign('ticket', $entityData)
                   // assign also the actual object for categories listener
                   ->assign('ticketObj', $entity)
                   ->assign('mode', $this->mode)
                   ->assign('inlineUsage', $this->inlineUsage);
        
        // assign ticketid if available
        $this->view->assign('ticketid', $ticketid);

        // save entity reference for reuse in handleCommand method
        $this->ticketRef = $entity;

        // load and assign registered categories
        $categories = CategoryRegistryUtil::getRegisteredModuleCategories('MUTicket', 'Ticket', 'id');
        $this->view->assign('registries', $categories);

        $this->initializeAdditions();

        // everything okay, no initialization errors occured
        return true;
    }

    /**
* Command event handler.
*
* This event handler is called when a command is issued by the user. Commands are typically something
* that originates from a {@link Zikula_Form_Plugin_Button} plugin. The passed args contains different properties
* depending on the command source, but you should at least find a <var>$args['commandName']</var>
* value indicating the name of the command. The command name is normally specified by the plugin
* that initiated the command.
* @see Zikula_Form_Plugin_Button
* @see Zikula_Form_Plugin_ImageButton
*/
    public function handleCommand(Zikula_Form_View $view, &$args)
    {
        if ($args['commandName'] == 'delete') {
            if (!SecurityUtil::checkPermission('MUTicket:Ticket:', '::', ACCESS_DELETE)) {
                return $this->view->setErrorMsg(LogUtil::registerPermissionError());
            }
        }

        $selectedRelations = array();
        // reassign the ticket eventually chosen by the user
        $selectedRelations['parent'] = $this->retrieveRelatedObjects('ticket', 'muticketTicket_ParentItemList', false, 'POST');
        // reassign the ratings eventually chosen by the user
        $selectedRelations['rating'] = $this->retrieveRelatedObjects('rating', 'muticketRating_RatingItemList', true, 'POST');
        // reassign the tickets eventually chosen by the user
        $selectedRelations['children'] = $this->retrieveRelatedObjects('ticket', 'muticketTicket_ChildrenItemList', true, 'POST');
        $this->view->assign('selectedRelations', $selectedRelations);

        if (!in_array($args['commandName'], array('delete', 'cancel'))) {
            // do forms validation including checking all validators on the page to validate their input
            if (!$this->view->isValid()) {
                return false;
            }
        }

        $this->objectType = 'ticket';

        $entityClass = 'MUTicket_Entity_' . ucfirst($this->objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        // get treated entity reference from persisted member var
        $ticket = $this->ticketRef;

        // fetch posted data input values as an associative array
        $formData = $this->view->getValues();
        // we want the array with our field values
        $ticketData = $formData['ticket'];
        unset($formData['ticket']);

        $ticketData['Parent'] = ((isset($selectedRelations['parent'])) ? $selectedRelations['parent'] : $this->retrieveRelatedObjects('ticket', 'muticketTicket_ParentItemList', false, 'POST'));

        if (in_array($args['commandName'], array('create', 'update'))) {
            $ticketData = $this->handleUploads($ticketData, $ticket);
            if ($ticketData == false) {
                return false;
            }
        }

            $repeatCreateAction = false;
        if (isset($ticketData['repeatcreation'])) {
            if ($args['commandName'] == 'create') {
                $repeatCreateAction = $ticketData['repeatcreation'];
            }
            unset($ticketData['repeatcreation']);
        }

        // assign fetched data
        $ticket->merge($ticketData);

        if (in_array($args['commandName'], array('create', 'update'))) {
            // event handling if user clicks on create or update

            // Let any hooks perform additional validation actions
            $hook = new Zikula_ValidationHook('muticket.ui_hooks.tickets.validate_edit', new Zikula_Hook_ValidationProviders());
            $validators = $this->notifyHooks($hook)->getValidators();
            // TODO validation incomplete (#36)

            // save ticket
            $successMessage = '';
            $this->updateRelationLinks($ticket);
            //$this->entityManager->transactional(function($entityManager) {
                $this->entityManager->persist($ticket);
                $this->entityManager->flush();
            //});

            if ($args['commandName'] == 'create') {
                $successMessage = $this->__('Done! Ticket created.');
            } else if ($args['commandName'] == 'update') {
                $successMessage = $this->__('Done! Ticket updated.');
            }

            if ($args['commandName'] == 'create') {
                // store new identifier
                $this->idValues['id'] = $ticket->getId();
                // check if the insert has worked, might become obsolete due to exception usage
                if (!$this->idValues['id']) {
                    return $this->view->setErrorMsg($this->__('Error! Creation attempt failed.'));
                }
            } else if ($args['commandName'] == 'update') {
            }

            LogUtil::registerStatus($successMessage);

            // Let any hooks know that we have created or updated an item
            $url = new Zikula_ModUrl('MUTicket', 'user', 'display', ZLanguage::getLanguageCode(), array('ot' => $this->objectType, 'id' => $this->idValues['id']));
            $hook = new Zikula_ProcessHook('muticket.ui_hooks.tickets.process_edit', $this->id, $url);
            $this->notifyHooks($hook);
        } else if ($args['commandName'] == 'delete') {
            // event handling if user clicks on delete

            // Let any hooks perform additional validation actions
            $hook = new Zikula_ValidationHook('muticket.ui_hooks.tickets.validate_delete', new Zikula_Hook_ValidationProviders());
            $validators = $this->notifyHooks($hook)->getValidators();
            // TODO validation incomplete (#36)

            // delete ticket
            $this->entityManager->remove($ticket);
            $this->entityManager->flush();

            LogUtil::registerStatus($this->__('Done! Ticket deleted.'));

            // Let any hooks know that we have deleted an item
            $hook = new Zikula_ProcessHook('muticket.ui_hooks.tickets.process_delete', $this->id);
            $this->notifyHooks($hook);
        } else if ($args['commandName'] == 'cancel') {
            // event handling if user clicks on cancel
        }

        if ($args['commandName'] != 'cancel') {
            // clear view cache to reflect our changes
            $this->view->clear_cache();
        }

        if ($this->mode == 'edit') {
            ModUtil::apiFunc('PageLock', 'user', 'releaseLock',
                             array('lockName' => 'MUTicketTicket' . $this->id));
        }
        return $this->view->redirect($this->getRedirectUrl($args, $ticket, $repeatCreateAction));

        // We should in principle not end here at all, since the above command handlers should
        // match all possible commands, but we return "ok" (true) for all cases.
        // You could also return $this->view->setErrorMsg('Unexpected command')
        return true;
    }
}
